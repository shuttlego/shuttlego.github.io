#!/usr/bin/env python3
"""shuttle-go 개발 환경 통합 실행 스크립트

기본 실행은 backend만 재빌드/재시작하고 프론트엔드를 함께 시작한다.
traefik은 기본 실행에서 재시작하지 않고, 내려가 있을 때만 시작한다.
--all 옵션을 주면 prometheus/grafana 등 나머지 구성요소까지 함께 (재)시작한다.

사용법:
    python run_dev.py              # 기본 시작 (backend rebuild/restart + frontend)
    python run_dev.py --all        # 전체 시작 (backend + monitoring + frontend)
    python run_dev.py --frontend   # 프론트엔드 서버만 시작
    python run_dev.py --down       # 기본 구성요소 종료(backend + frontend 포트 정리)
    python run_dev.py --down --all # 전체 종료
"""

import argparse
import http.server
import os
import signal
import socket
import subprocess
import sys
import threading
import time
import urllib.request

PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))
ENV_FILE = os.path.join(PROJECT_DIR, ".env")
DEV_CONFIG_JS = os.path.join(PROJECT_DIR, "dev.config.js")
DEFAULT_FRONTEND_PORT = 8080
DEFAULT_BACKEND_HTTP_PORT = 80
DEFAULT_BACKEND_HTTPS_PORT = 443
COMPOSE_TIMEOUT = 60  # 컨테이너 healthy 대기 최대 초
HEALTH_POLL_INTERVAL_SEC = 1.0
FRONTEND_PORT = DEFAULT_FRONTEND_PORT
BACKEND_HTTP_PORT = DEFAULT_BACKEND_HTTP_PORT
BACKEND_HTTPS_PORT = DEFAULT_BACKEND_HTTPS_PORT
HEALTH_URL = ""
CORE_SERVICES = ("backend",)
GATEWAY_SERVICE = "traefik"


# ── 유틸 ──────────────────────────────────────────────────

def log(msg: str) -> None:
    print(f"\033[1;36m[shuttle-go]\033[0m {msg}", flush=True)


def err(msg: str) -> None:
    print(f"\033[1;31m[shuttle-go]\033[0m {msg}", flush=True)


def run(cmd: str, **kwargs) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, shell=True, cwd=PROJECT_DIR, **kwargs)


def is_port_in_use(port: int) -> bool:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(("127.0.0.1", port)) == 0


def load_env_file(path: str) -> dict[str, str]:
    values: dict[str, str] = {}
    if not os.path.exists(path):
        return values
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                continue
            if stripped.startswith("export "):
                stripped = stripped[len("export ") :].strip()
            if "=" not in stripped:
                continue
            key, raw_value = stripped.split("=", 1)
            key = key.strip()
            value = raw_value.strip()
            if (
                len(value) >= 2
                and ((value[0] == value[-1] == '"') or (value[0] == value[-1] == "'"))
            ):
                value = value[1:-1]
            values[key] = value
    return values


def get_env_int(env_map: dict[str, str], key: str, default: int) -> int:
    raw = os.environ.get(key, env_map.get(key, str(default))).strip()
    try:
        value = int(raw)
    except ValueError:
        err(f"{key} 값이 정수가 아닙니다: {raw}")
        sys.exit(1)
    if value < 1 or value > 65535:
        err(f"{key} 값은 1~65535 범위여야 합니다: {value}")
        sys.exit(1)
    return value


def local_url(path: str, port: int, scheme: str = "http") -> str:
    default_port = 80 if scheme == "http" else 443
    if port == default_port:
        return f"{scheme}://localhost{path}"
    return f"{scheme}://localhost:{port}{path}"


def write_dev_config_js() -> None:
    content = (
        "// Auto-generated by run_dev.py\n"
        "window.__SHUTTLE_DEV_CONFIG = Object.assign({}, window.__SHUTTLE_DEV_CONFIG || {}, {\n"
        f"  API_HTTP_PORT: {BACKEND_HTTP_PORT},\n"
        f"  API_HTTPS_PORT: {BACKEND_HTTPS_PORT}\n"
        "});\n"
    )
    with open(DEV_CONFIG_JS, "w", encoding="utf-8") as f:
        f.write(content)


def configure_runtime_ports(validate_conflict: bool = True) -> None:
    global FRONTEND_PORT, BACKEND_HTTP_PORT, BACKEND_HTTPS_PORT, HEALTH_URL
    env_map = load_env_file(ENV_FILE)
    FRONTEND_PORT = get_env_int(env_map, "FRONTEND_PORT", DEFAULT_FRONTEND_PORT)
    BACKEND_HTTP_PORT = get_env_int(env_map, "BACKEND_HTTP_PORT", DEFAULT_BACKEND_HTTP_PORT)
    BACKEND_HTTPS_PORT = get_env_int(env_map, "BACKEND_HTTPS_PORT", DEFAULT_BACKEND_HTTPS_PORT)

    if validate_conflict and FRONTEND_PORT == BACKEND_HTTP_PORT:
        err(
            "FRONTEND_PORT와 BACKEND_HTTP_PORT가 동일합니다. "
            f"(현재 {FRONTEND_PORT}) .env에서 둘 중 하나를 변경하세요."
        )
        sys.exit(1)

    HEALTH_URL = local_url("/health", BACKEND_HTTP_PORT, scheme="http")


# ── Docker Compose ────────────────────────────────────────

def wait_backend_healthy(timeout_sec: int) -> bool:
    log(
        "백엔드 health check 대기 … "
        f"(최대 {timeout_sec}초, {int(HEALTH_POLL_INTERVAL_SEC)}초 간격 폴링)"
    )
    deadline = time.monotonic() + timeout_sec
    while True:
        poll_started = time.monotonic()
        try:
            with urllib.request.urlopen(HEALTH_URL, timeout=HEALTH_POLL_INTERVAL_SEC) as resp:
                if resp.status == 200:
                    log("백엔드 정상 (healthy)")
                    return True
        except Exception:
            pass

        now = time.monotonic()
        if now >= deadline:
            return False
        sleep_for = min(
            HEALTH_POLL_INTERVAL_SEC,
            max(0.0, HEALTH_POLL_INTERVAL_SEC - (now - poll_started)),
            deadline - now,
        )
        if sleep_for > 0:
            time.sleep(sleep_for)


def compose_down(all_services: bool = False) -> None:
    if all_services:
        log("Docker Compose 전체 종료 중 …")
        run("docker compose down", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        log("Docker Compose 전체 종료 완료")
        return

    services = " ".join(CORE_SERVICES)
    log(f"Docker Compose 기본 구성요소 종료 중 … ({services})")
    run(f"docker compose stop {services}", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    run(f"docker compose rm -f {services}", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    log("Docker Compose 기본 구성요소 종료 완료")


def compose_up_core() -> None:
    # 기본 실행에서는 traefik을 재시작/재빌드하지 않는다.
    # 다만 내려가 있으면 API 접근 경로 확보를 위해 시작만 수행한다.
    gateway_running = run(
        f"docker compose ps --status running -q {GATEWAY_SERVICE}",
        capture_output=True,
        text=True,
    )
    if not gateway_running.stdout.strip():
        log("traefik 미실행 상태 감지 → 시작만 수행 (재시작/재빌드 없음)")
        gateway_ret = run(f"docker compose up -d {GATEWAY_SERVICE}")
        if gateway_ret.returncode != 0:
            err("traefik 시작 실패")
            sys.exit(1)
    else:
        log("traefik 실행 중 → 재시작 없이 유지")

    services = " ".join(CORE_SERVICES)
    log(f"기본 구성요소 빌드 & 시작 … ({services})")
    ret = run(f"docker compose up -d --build --force-recreate {services}")
    if ret.returncode != 0:
        err("기본 구성요소 docker compose up 실패")
        sys.exit(1)

    if not wait_backend_healthy(COMPOSE_TIMEOUT):
        err(f"{COMPOSE_TIMEOUT}초 내에 백엔드가 응답하지 않았습니다")
        sys.exit(1)


def compose_up_all() -> None:
    # --all은 전체 스택을 재시작해야 하므로 down -> up 순으로 강제
    result = run("docker compose ps -q", capture_output=True, text=True)
    if result.stdout.strip():
        log("기존 컨테이너 감지 → 전체 재시작합니다 …")
        run("docker compose down", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    log("Docker Compose 전체 빌드 & 시작 …")
    ret = run("docker compose up -d --build")
    if ret.returncode != 0:
        err("docker compose up 실패")
        sys.exit(1)

    if not wait_backend_healthy(COMPOSE_TIMEOUT):
        err(f"{COMPOSE_TIMEOUT}초 내에 백엔드가 응답하지 않았습니다")
        sys.exit(1)


# ── 프론트엔드 정적 서버 ──────────────────────────────────

def start_frontend() -> None:
    if is_port_in_use(FRONTEND_PORT):
        log(f"포트 {FRONTEND_PORT} 이미 사용 중 → 기존 프로세스 종료 시도")
        run(f"lsof -ti :{FRONTEND_PORT} | xargs kill -9 2>/dev/null")
        time.sleep(0.5)

    os.chdir(PROJECT_DIR)
    write_dev_config_js()

    class QuietHandler(http.server.SimpleHTTPRequestHandler):
        """BrokenPipe / ConnectionReset 등 클라이언트 끊김 에러를 조용히 무시"""
        def log_message(self, format, *args):
            # 기본 로그는 그대로 출력
            super().log_message(format, *args)

    class QuietServer(http.server.ThreadingHTTPServer):
        def handle_error(self, request, client_address):
            import traceback
            exc = sys.exc_info()[1]
            if isinstance(exc, (BrokenPipeError, ConnectionResetError, ConnectionAbortedError)):
                log(f"⚠ 클라이언트 연결 끊김 ({client_address[0]}:{client_address[1]}) — 무시")
            else:
                super().handle_error(request, client_address)

    httpd = QuietServer(("0.0.0.0", FRONTEND_PORT), QuietHandler)

    thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    thread.start()
    log(f"프론트엔드 서버 시작 → http://localhost:{FRONTEND_PORT}")
    return httpd


def wait_forever(httpd) -> None:
    """Ctrl+C 대기 후 프론트엔드 서버 종료"""
    try:
        signal.pause()
    except (KeyboardInterrupt, AttributeError):
        # Windows에는 signal.pause()가 없으므로 fallback
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            pass

    httpd.shutdown()
    log("프론트엔드 서버 종료")


# ── 메인 ──────────────────────────────────────────────────

def main() -> None:
    parser = argparse.ArgumentParser(description="shuttle-go 개발 환경 통합 실행")
    parser.add_argument("--down", action="store_true", help="종료 (기본: backend만, --all: 전체)")
    parser.add_argument("--all", action="store_true", help="모든 구성요소까지 재시작")
    parser.add_argument("--frontend", action="store_true", help="프론트엔드 서버만 시작")
    args = parser.parse_args()
    configure_runtime_ports(validate_conflict=not args.down)

    if args.down:
        compose_down(all_services=args.all)
        log(f"포트 {FRONTEND_PORT} 정리")
        run(f"lsof -ti :{FRONTEND_PORT} | xargs kill -9 2>/dev/null")
        log("완료")
        return

    if args.frontend:
        httpd = start_frontend()
        print()
        log("═══════════════════════════════════════════")
        log(f"  프론트엔드  → {local_url('', FRONTEND_PORT, scheme='http')}")
        log(f"  백엔드 API  → {local_url('/api/sites', BACKEND_HTTP_PORT, scheme='http')}")
        log("═══════════════════════════════════════════")
        log("Ctrl+C 로 종료")
        print()
        wait_forever(httpd)
        return

    if args.all:
        compose_up_all()
    else:
        compose_up_core()
    httpd = start_frontend()

    # 컨테이너 상태 출력
    log("실행 중인 서비스:")
    if args.all:
        run("docker compose ps")
    else:
        run(f"docker compose ps {' '.join(CORE_SERVICES)}")

    print()
    log("═══════════════════════════════════════════")
    log(f"  프론트엔드  → {local_url('', FRONTEND_PORT, scheme='http')}")
    log(f"  백엔드 API  → {local_url('/api/sites', BACKEND_HTTP_PORT, scheme='http')}")
    if args.all:
        log(f"  Grafana     → {local_url('/grafana/', BACKEND_HTTP_PORT, scheme='http')}")
    log("═══════════════════════════════════════════")
    log("Ctrl+C 로 프론트엔드 서버 종료 (Docker 컨테이너는 유지)")
    log("전체 종료: python run_dev.py --down")
    print()

    wait_forever(httpd)


if __name__ == "__main__":
    main()
