# xlsx → CSV 변환 스크립트 설계안

## 1. 대상 파일 및 출력

- **입력**: `data/raw/` 아래 **파일명이 "삼성전자(수원)"으로 시작하는** `.xlsx` 파일만 처리  
  - 현재: `삼성전자(수원)#서울.xlsx`, `삼성전자(수원)#수원.xlsx`, `삼성전자(수원)#시외.xlsx`
- **출력**: `data/` 아래 4개 CSV  
  - **sites.csv**: 수정하지 않음 (현재 사업장 1개만 있음).
  - **routes.csv**, **departure_times.csv**, **stops.csv**: xlsx 파싱 결과로 채움.

---

## 2. xlsx 구조 (분석 결과)

- **시트**: `출근`, `퇴근` 두 개만 사용.
- **공통 레이아웃**:
  - 1행: 제목 (예: "서울지역 평일 출근노선") → 스킵.
  - 2행: 헤더. 컬럼 순서는 고정, 이름만 약간 다름.
    - 출근: `행선지` 또는 `노선명`
    - 출근: `정차장` 또는 `정류장`
    - 출근: `출발시간` 또는 `기점출발시간`
    - 공통: `운행업체`, `비고`
  - 3행~: 데이터. **같은 노선이 여러 시간대**일 때는 **첫 행에만** 노선명·정차장·운행업체·비고가 있고, 이후 행은 보통 (None, None, 시간, None, None).

- **노선 그룹화**:  
  첫 번째 컬럼(행선지/노선명)에 값이 있는 행 = 새 노선 시작.  
  그 다음 행들은 같은 노선의 추가 출발시간으로 간주.

- **route_name**: 첫 컬럼 값에 `\n` 포함 가능 (예: `강남\n 고속터미널`). 저장 시 공백 정규화·줄바꿈 제거 등으로 하나의 문자열로 정리 필요.

---

## 3. routes.csv 설계

- **기존 컬럼**: `route_id`, `site_id`, `route_name`, `type`
- **추가 컬럼**: `operator`(운행업체), `notes`(비고)  
  → 기존 CSV와의 호환을 위해 스크립트에서 헤더 한 번 갱신 필요.

**규칙**

- `route_id`: 전역 유니크. 예: 1부터 순번 부여 (기존 1–4와 충돌 방지를 위해, **xlsx 기반으로 routes를 완전 재생성**하면 1부터 다시 부여하는 방식이 단순함).
- `site_id`: 모두 `1` (삼성전자(수원)).
- `route_name`: xlsx 첫 컬럼 값. `\n` → 공백 등으로 정리.
- `type`: 시트 기준  
  - `출근` → `1`  
  - `퇴근` → `2`
- `operator` / `notes`: 해당 노선의 첫 데이터 행에서 4·5번째 컬럼 값.

**정책 선택**

- **A안**: xlsx만 보고 routes/departure_times/stops를 **완전 재생성** (기존 routes 1–4 제거, xlsx에 있는 노선만 남김).
- **B안**: 기존 routes.csv를 읽어 최대 `route_id`를 구한 뒤, 그 다음 번호부터 **추가만** (기존 4개 노선 유지).

설계 단계에서는 **A안(재생성)**을 기본으로 두고, 필요 시 B안 옵션으로 전환하는 식으로 구현하면 됨.

---

## 4. departure_times.csv 설계

- **컬럼**: `route_id`, `time`
- `route_id`: 위에서 부여한 `routes.route_id`와 동일.
- `time`: xlsx의 “출발시간/기점출발시간” 컬럼(3번째 컬럼).

**시간 값 형태 (실제 xlsx 기준)**

1. **단일 시간**: 셀 타입이 `datetime.time` → `"HH:MM"` 문자열로 저장 (예: `06:30`).
2. **범위**: 문자열 (예: `"06:20 \n ~\n 07:35"`, `"06:40\n ~\n 07:10"`).  
   파싱 시 `~` 또는 `~\n` 등으로 split → 시작/종료 시간 추출.

**범위 처리 옵션 (아이디어)**

- **옵션 1 – 구간 내 N분 간격 모두 생성**  
  - 예: 06:20 ~ 07:35 → 5분 간격이면 06:20, 06:25, …, 07:35 여러 행.  
  - 장점: 사용자에게 “이 구간에 여러 번 출발”처럼 보여주기 좋음.  
  - 단점: 행 수 증가, 실제 배차와 다를 수 있음.

- **옵션 2 – 시작·종료만 저장**  
  - 한 노선에 `06:20`, `07:35` 두 행만.  
  - 장점: 데이터 단순.  
  - 단점: “몇 분 간격” 정보 없음.

- **옵션 3 – 시작만 저장**  
  - 한 행만 `06:20`.  
  - 장점: 가장 단순.  
  - 단점: “~ 07:35” 정보 손실.

- **옵션 4 – 시작·종료 + 중간을 고정 간격(예: 10분)으로 생성**  
  - 06:20, 06:30, 06:40, …, 07:30, 07:35 식.  
  - 실무에서는 “만차 시 출발” 등으로 구간만 표시하는 경우가 많으므로, 간격은 설정 가능하게 두는 것이 유연함.

**권장**:  
- 기본은 **옵션 2(시작·종료만)** 또는 **옵션 4(고정 간격, 기본 10분)** 중 하나로 두고,  
- 설정(예: `RANGE_INTERVAL_MINUTES=10` 또는 `RANGE_MODE=start_end_only`)으로 바꿀 수 있게 하면 좋음.

**파싱 구현 요지**

- 문자열이면 정규식으로 `HH:MM` 두 개 추출 (공백·`\n`·`~` 무시).
- `datetime.time`이면 그대로 `strftime("%H:%M")`.

---

## 5. stops.csv 설계

- **컬럼**: `route_id`, `sequence`, `stop_name`, `lat`, `lng`
- `route_id`: 동일하게 routes의 `route_id`.
- `sequence`: 1, 2, 3, … 순서 번호.

**정차장/정류장 셀 파싱**

- **정류장명 정규화**  
  - xlsx 셀에 큰따옴표(`"`)가 들어 있으면 그대로 파싱되어 CSV에 저장된다. CSV 규격상 필드 안에 `"`가 있으면 해당 필드를 `"`로 감싸고 내부의 `"`는 `""`로 이스케이프하므로, 저장·읽기 시 따옴표가 겹쳐 보이거나 필드가 깨질 수 있다. 따라서 파싱 단계에서 정류장명의 `"`는 제거한다.  
  - 번호+점 형식은 `1. xxx` 뿐 아니라 `3 xxx`(점 생략), `4 .명지대`(숫자와 점 사이 공백) 등 변형을 허용하는 정규식으로 처리한다.

- **출근 탭**  
  - 한 셀에 여러 정류장이 `"1. xxx\n 2. yyy\n 3. zzz"` 형태로 있음.  
  - `\n`으로 split → 각 줄에서 숫자+점+공백 제거 후 문자열만 추출 → `stop_name`으로 사용, 순서대로 `sequence` 부여.

- **퇴근 탭**  
  - 첫 줄이 `"(이용 장소 : 정문 버스승차장)"` 또는 `"(이용장소: xx)"` 형태.  
  - 설계: **괄호 안의 “: ” 뒤 문자열**을 sequence 1의 `stop_name`으로 사용 (예: `정문 버스승차장`).  
  - 그 다음 줄부터는 출근과 동일하게 `"1. xxx"`, `"2. yyy"` … 파싱하여 sequence 2, 3, … 로 넣음.  
  - 괄호 줄에 “1. ”이 없으므로, “(이용 장소 : …)” 패턴을 먼저 처리한 뒤 나머지를 번호 목록으로 파싱하면 됨.

**위경도(lat, lng)**

- **방안 1 – 기존 stops.csv 활용**  
  - 이미 있는 `stop_name`과 문자열 매칭(정규화: 공백·괄호 제거, 유사도 등)으로 기존 lat/lng 재사용.  
  - 새 정류장만 빈값 또는 NULL로 두고, 나중에 수동/배치로 보강.

- **방안 2 – 외부 Geocoding API**  
  - 카카오/네이버/구글 등으로 `stop_name` 주소/장소 검색 → lat/lng 채움.  
  - API 키·할당량·비용 고려 필요.  
  - “양재역 3번 출구” 같은 설명형 문자열은 그대로 검색 시 실패할 수 있으므로, “양재역” 등 핵심어만 검색하는 전처리 가능.

- **방안 3 – 비워두기**  
  - lat/lng를 빈 값 또는 `""`로 두고, 스크립트는 `stop_name`·`sequence`만 채움.  
  - 나중에 별도 지오코딩 스크립트/수동 입력으로 채움.

**권장**:  
- 1단계: **방안 3**으로 구현해 두고,  
- 2단계: 기존 `data/stops.csv`와 **방안 1**로 이름 매칭해 가능한 것만 자동 채우기.  
- Geocoding API는 옵션(환경 변수로 키 있으면 호출)으로 두면 확장하기 좋음.

---

## 6. 처리 흐름 (스크립트 단계)

1. **파일 목록**: `data/raw/`에서 `삼성전자(수원)*.xlsx` 수집.
2. **공통 준비**:  
   - routes/departure_times/stops용 리스트(또는 임시 테이블) 준비.  
   - route_id는 1부터 증가하는 카운터로 관리.
3. **시트별** (출근 → 퇴근 순서로 고정해도 됨):  
   - 1행 스킵, 2행으로 컬럼 인덱스 확인(선택).  
   - 3행부터 순회:
     - 첫 컬럼에 값 있음 → 새 노선 시작: route_name·operator·notes 저장, route_id 할당, 정차장 텍스트 수집.
     - 같은 노선이면: 출발시간만 추가 수집.
   - 출발시간: 단일/범위 파싱 후 위 규칙대로 행 생성.  
   - 정차장: 출근/퇴근 규칙에 따라 stop_name·sequence 생성.
4. **routes.csv**:  
   - 헤더에 `operator`, `notes` 포함.  
   - 수집한 route_id, site_id=1, route_name, type, operator, notes 쓰기.
5. **departure_times.csv**:  
   - 기존 형식 유지. route_id + time 행 쓰기.
6. **stops.csv**:  
   - route_id, sequence, stop_name, lat, lng.  
   - lat/lng는 설계한 방안(비움/기존 매칭/API)에 따라 채우기.

---

## 7. 기술적 참고

- **라이브러리**: `openpyxl` (xlsx 읽기, `data_only=True`로 값만 읽기).  
  - `datetime.time`은 그대로 사용, 문자열 시간은 정규식 또는 간단한 파싱으로 처리.
- **인코딩**: CSV는 UTF-8로 저장 (BOM 여부는 기존 CSV와 맞추면 됨).
- **기존 데이터**:  
  - sites.csv는 읽지 않고 그대로 둠.  
  - routes/departure_times/stops는 위 “정책 선택”에 따라 재생성 또는 append.

이 설계대로 구현하면 요구사항 1~7을 모두 만족하는 스크립트를 만들 수 있습니다. 스크립트 작성 시에는 위 단계를 그대로 함수/단위별로 나누어 구현하면 됩니다.
